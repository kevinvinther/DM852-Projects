<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: DM852::Tree&lt; Key, Value, Comp &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>DM852</b></li><li class="navelem"><a class="el" href="classDM852_1_1Tree.html">Tree</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classDM852_1_1Tree-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">DM852::Tree&lt; Key, Value, Comp &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A binary search tree.  
 <a href="classDM852_1_1Tree.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Tree_8hpp_source.html">Tree.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDM852_1_1Tree_1_1const__iterator.html">const_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDM852_1_1Tree_1_1iterator.html">iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2cdabfd50d18bedb81601092e0f96ff3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDM852_1_1Tree.html#a2cdabfd50d18bedb81601092e0f96ff3">value_type</a> = std::pair&lt; const Key, Value &gt;</td></tr>
<tr class="separator:a2cdabfd50d18bedb81601092e0f96ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac934fb3a074d9f89734a97e437c864f5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDM852_1_1Tree.html#ac934fb3a074d9f89734a97e437c864f5">Tree</a> ()</td></tr>
<tr class="memdesc:ac934fb3a074d9f89734a97e437c864f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor for tree.  <br /></td></tr>
<tr class="separator:ac934fb3a074d9f89734a97e437c864f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af201642218382945e9e05dae06ccf5eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDM852_1_1Tree.html#af201642218382945e9e05dae06ccf5eb">Tree</a> (Comp comp)</td></tr>
<tr class="memdesc:af201642218382945e9e05dae06ccf5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for tree with a comparison function.  <br /></td></tr>
<tr class="separator:af201642218382945e9e05dae06ccf5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5052385cd0e4438e8790218d957e8fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDM852_1_1Tree.html#af5052385cd0e4438e8790218d957e8fc">Tree</a> (const <a class="el" href="classDM852_1_1Tree.html">Tree</a> &amp;other)</td></tr>
<tr class="memdesc:af5052385cd0e4438e8790218d957e8fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor for tree.  <br /></td></tr>
<tr class="separator:af5052385cd0e4438e8790218d957e8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977e208a0928ae9384f8e1b4b8c6c1f6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDM852_1_1Tree.html#a977e208a0928ae9384f8e1b4b8c6c1f6">Tree</a> (<a class="el" href="classDM852_1_1Tree.html">Tree</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a977e208a0928ae9384f8e1b4b8c6c1f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor for tree.  <br /></td></tr>
<tr class="separator:a977e208a0928ae9384f8e1b4b8c6c1f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a3358d3236ed0de8a6c7d06b45f44d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDM852_1_1Tree.html">Tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDM852_1_1Tree.html#a51a3358d3236ed0de8a6c7d06b45f44d">operator=</a> (const <a class="el" href="classDM852_1_1Tree.html">Tree</a> &amp;other)</td></tr>
<tr class="memdesc:a51a3358d3236ed0de8a6c7d06b45f44d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator for tree.  <br /></td></tr>
<tr class="separator:a51a3358d3236ed0de8a6c7d06b45f44d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf2c770102639da93495434b9e09f86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDM852_1_1Tree.html">Tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDM852_1_1Tree.html#acbf2c770102639da93495434b9e09f86">operator=</a> (<a class="el" href="classDM852_1_1Tree.html">Tree</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:acbf2c770102639da93495434b9e09f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator for tree.  <br /></td></tr>
<tr class="separator:acbf2c770102639da93495434b9e09f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd58d8a437aa0a5d9935bf410cc30b2a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDM852_1_1Tree.html#abd58d8a437aa0a5d9935bf410cc30b2a">~Tree</a> ()</td></tr>
<tr class="memdesc:abd58d8a437aa0a5d9935bf410cc30b2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor for tree.  <br /></td></tr>
<tr class="separator:abd58d8a437aa0a5d9935bf410cc30b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493339e5d0f271518b3db3e257c71cff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDM852_1_1Tree.html#a493339e5d0f271518b3db3e257c71cff">operator==</a> (const <a class="el" href="classDM852_1_1Tree.html">Tree</a> &amp;other)</td></tr>
<tr class="memdesc:a493339e5d0f271518b3db3e257c71cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for tree.  <br /></td></tr>
<tr class="separator:a493339e5d0f271518b3db3e257c71cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8039736d915341aae5604d8be6e170a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDM852_1_1Tree.html#a8039736d915341aae5604d8be6e170a5">operator==</a> (const <a class="el" href="classDM852_1_1Tree.html">Tree</a> &amp;other) const</td></tr>
<tr class="memdesc:a8039736d915341aae5604d8be6e170a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const equality operator for tree.  <br /></td></tr>
<tr class="separator:a8039736d915341aae5604d8be6e170a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48138501534ed99f9841a1a1ce417140"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDM852_1_1Tree.html#a48138501534ed99f9841a1a1ce417140">operator!=</a> (const <a class="el" href="classDM852_1_1Tree.html">Tree</a> &amp;other)</td></tr>
<tr class="memdesc:a48138501534ed99f9841a1a1ce417140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for tree.  <br /></td></tr>
<tr class="separator:a48138501534ed99f9841a1a1ce417140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a691e59dbd7ba851da76c29393b1905"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDM852_1_1Tree.html#a4a691e59dbd7ba851da76c29393b1905">operator!=</a> (const <a class="el" href="classDM852_1_1Tree.html">Tree</a> &amp;other) const</td></tr>
<tr class="memdesc:a4a691e59dbd7ba851da76c29393b1905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const inequality operator for tree.  <br /></td></tr>
<tr class="separator:a4a691e59dbd7ba851da76c29393b1905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa97797b70c35cf0120a59640d39ac84e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDM852_1_1Tree.html#aa97797b70c35cf0120a59640d39ac84e">iteratorTraversal</a> (const <a class="el" href="classDM852_1_1Tree.html">Tree</a> &amp;other) const</td></tr>
<tr class="memdesc:aa97797b70c35cf0120a59640d39ac84e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for tree.  <br /></td></tr>
<tr class="separator:aa97797b70c35cf0120a59640d39ac84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d40f18d5b1e41c189415022eb3dc6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDM852_1_1Tree.html#aa5d40f18d5b1e41c189415022eb3dc6e">clear</a> ()</td></tr>
<tr class="memdesc:aa5d40f18d5b1e41c189415022eb3dc6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears tree to empty state.  <br /></td></tr>
<tr class="separator:aa5d40f18d5b1e41c189415022eb3dc6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92c830c94abb527ad8905488bd7e087"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDM852_1_1Tree.html#af92c830c94abb527ad8905488bd7e087">clearTraversal</a> (Node *node)</td></tr>
<tr class="memdesc:af92c830c94abb527ad8905488bd7e087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all nodes in tree recursively.  <br /></td></tr>
<tr class="separator:af92c830c94abb527ad8905488bd7e087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a789be3885bde03a00a7254e808e54cbf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDM852_1_1Tree.html#a789be3885bde03a00a7254e808e54cbf">size</a> () const</td></tr>
<tr class="memdesc:a789be3885bde03a00a7254e808e54cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the tree.  <br /></td></tr>
<tr class="separator:a789be3885bde03a00a7254e808e54cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503d781b0509aa27dee80ff16228c073"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDM852_1_1Tree.html#a503d781b0509aa27dee80ff16228c073">empty</a> () const</td></tr>
<tr class="memdesc:a503d781b0509aa27dee80ff16228c073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not the tree is empty.  <br /></td></tr>
<tr class="separator:a503d781b0509aa27dee80ff16228c073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4508918bb03bd7ca2a6b7d50ed8ee603"><td class="memItemLeft" align="right" valign="top">Node *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDM852_1_1Tree.html#a4508918bb03bd7ca2a6b7d50ed8ee603">findNode</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:a4508918bb03bd7ca2a6b7d50ed8ee603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds node from key.  <br /></td></tr>
<tr class="separator:a4508918bb03bd7ca2a6b7d50ed8ee603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f954a0edfb18670555e188c83605393"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classDM852_1_1Tree_1_1iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDM852_1_1Tree.html#a8f954a0edfb18670555e188c83605393">insert</a> (const Key &amp;key, const Value &amp;value)</td></tr>
<tr class="memdesc:a8f954a0edfb18670555e188c83605393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts node into tree.  <br /></td></tr>
<tr class="separator:a8f954a0edfb18670555e188c83605393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e32bbf2d5e32613d0322898561cdac"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classDM852_1_1Tree_1_1iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDM852_1_1Tree.html#a75e32bbf2d5e32613d0322898561cdac">insert</a> (Key &amp;&amp;key, Value &amp;&amp;value)</td></tr>
<tr class="memdesc:a75e32bbf2d5e32613d0322898561cdac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts node into tree using move semantics.  <br /></td></tr>
<tr class="separator:a75e32bbf2d5e32613d0322898561cdac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a383685f0ef7d362693c4286d10581d0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDM852_1_1Tree_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDM852_1_1Tree.html#a383685f0ef7d362693c4286d10581d0c">find</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:a383685f0ef7d362693c4286d10581d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds node from key and returns an iterator to it.  <br /></td></tr>
<tr class="separator:a383685f0ef7d362693c4286d10581d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244c259c1dc96e88bf9434c865226dd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDM852_1_1Tree_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDM852_1_1Tree.html#a244c259c1dc96e88bf9434c865226dd1">find</a> (const Key &amp;key) const</td></tr>
<tr class="memdesc:a244c259c1dc96e88bf9434c865226dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds node from key and returns a <a class="el" href="classDM852_1_1Tree_1_1const__iterator.html">const_iterator</a> to it.  <br /></td></tr>
<tr class="separator:a244c259c1dc96e88bf9434c865226dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af555e96592be4c5fbac4f2049221a9f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDM852_1_1Tree_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDM852_1_1Tree.html#af555e96592be4c5fbac4f2049221a9f2">begin</a> ()</td></tr>
<tr class="memdesc:af555e96592be4c5fbac4f2049221a9f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator to the first node in the tree.  <br /></td></tr>
<tr class="separator:af555e96592be4c5fbac4f2049221a9f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98a4e70dfba04329932b519e49a637a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDM852_1_1Tree_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDM852_1_1Tree.html#ad98a4e70dfba04329932b519e49a637a">begin</a> () const</td></tr>
<tr class="memdesc:ad98a4e70dfba04329932b519e49a637a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classDM852_1_1Tree_1_1const__iterator.html">const_iterator</a> to the first node in the tree.  <br /></td></tr>
<tr class="separator:ad98a4e70dfba04329932b519e49a637a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8fa471527960e1c1989ccb933d397b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDM852_1_1Tree_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDM852_1_1Tree.html#afc8fa471527960e1c1989ccb933d397b">end</a> ()</td></tr>
<tr class="memdesc:afc8fa471527960e1c1989ccb933d397b"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator to the node after the last node in the tree.  <br /></td></tr>
<tr class="separator:afc8fa471527960e1c1989ccb933d397b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f93254b826a644642c5a9e66e1de320"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDM852_1_1Tree_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDM852_1_1Tree.html#a5f93254b826a644642c5a9e66e1de320">end</a> () const</td></tr>
<tr class="memdesc:a5f93254b826a644642c5a9e66e1de320"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classDM852_1_1Tree_1_1const__iterator.html">const_iterator</a> to the node after the last node in the tree.  <br /></td></tr>
<tr class="separator:a5f93254b826a644642c5a9e66e1de320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759aaf94b760b7a8aaa5fcd345535843"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDM852_1_1Tree.html#a2cdabfd50d18bedb81601092e0f96ff3">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDM852_1_1Tree.html#a759aaf94b760b7a8aaa5fcd345535843">front</a> ()</td></tr>
<tr class="memdesc:a759aaf94b760b7a8aaa5fcd345535843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the key-value pair of the first node.  <br /></td></tr>
<tr class="separator:a759aaf94b760b7a8aaa5fcd345535843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bde2a5d277a75074f4bf7d6000f16d1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDM852_1_1Tree.html#a2cdabfd50d18bedb81601092e0f96ff3">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDM852_1_1Tree.html#a7bde2a5d277a75074f4bf7d6000f16d1">front</a> () const</td></tr>
<tr class="memdesc:a7bde2a5d277a75074f4bf7d6000f16d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the key-value pair of the first node.  <br /></td></tr>
<tr class="separator:a7bde2a5d277a75074f4bf7d6000f16d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8dc4c1e98cda3a8c2c79a5c9c395e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDM852_1_1Tree.html#a2cdabfd50d18bedb81601092e0f96ff3">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDM852_1_1Tree.html#a0e8dc4c1e98cda3a8c2c79a5c9c395e3">back</a> ()</td></tr>
<tr class="memdesc:a0e8dc4c1e98cda3a8c2c79a5c9c395e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the key-value pair of the last node.  <br /></td></tr>
<tr class="separator:a0e8dc4c1e98cda3a8c2c79a5c9c395e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1509d3564e7423cdb5d2d2f299f272"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDM852_1_1Tree.html#a2cdabfd50d18bedb81601092e0f96ff3">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDM852_1_1Tree.html#aec1509d3564e7423cdb5d2d2f299f272">back</a> () const</td></tr>
<tr class="memdesc:aec1509d3564e7423cdb5d2d2f299f272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the key-value pair of the last node.  <br /></td></tr>
<tr class="separator:aec1509d3564e7423cdb5d2d2f299f272"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Key, typename Value, typename Comp = std::less&lt;Key&gt;&gt;<br />
class DM852::Tree&lt; Key, Value, Comp &gt;</div><p>A binary search tree. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Key</td><td>The key type </td></tr>
    <tr><td class="paramname">Value</td><td>The value type </td></tr>
    <tr><td class="paramname">Comp</td><td>The comparison function</td></tr>
  </table>
  </dd>
</dl>
<p>This tree is not a red-black tree, i.e., it is <em>not</em> self-balancing. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a2cdabfd50d18bedb81601092e0f96ff3" name="a2cdabfd50d18bedb81601092e0f96ff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cdabfd50d18bedb81601092e0f96ff3">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename Comp  = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDM852_1_1Tree.html">DM852::Tree</a>&lt; Key, Value, Comp &gt;::value_type =  std::pair&lt;const Key, Value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The value type, a pair consisting of the key and the value of a node </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac934fb3a074d9f89734a97e437c864f5" name="ac934fb3a074d9f89734a97e437c864f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac934fb3a074d9f89734a97e437c864f5">&#9670;&#160;</a></span>Tree() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename Comp  = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDM852_1_1Tree.html">DM852::Tree</a>&lt; Key, Value, Comp &gt;::Tree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor for tree. </p>
<p>Initializes all the values to their default values. </p>

</div>
</div>
<a id="af201642218382945e9e05dae06ccf5eb" name="af201642218382945e9e05dae06ccf5eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af201642218382945e9e05dae06ccf5eb">&#9670;&#160;</a></span>Tree() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename Comp  = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDM852_1_1Tree.html">DM852::Tree</a>&lt; Key, Value, Comp &gt;::Tree </td>
          <td>(</td>
          <td class="paramtype">Comp&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for tree with a comparison function. </p>
<p>Initializes all the values to their default values, and sets the comparison function to the one given.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>The comparison function to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5052385cd0e4438e8790218d957e8fc" name="af5052385cd0e4438e8790218d957e8fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5052385cd0e4438e8790218d957e8fc">&#9670;&#160;</a></span>Tree() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename Comp  = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDM852_1_1Tree.html">DM852::Tree</a>&lt; Key, Value, Comp &gt;::Tree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDM852_1_1Tree.html">Tree</a>&lt; Key, Value, Comp &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor for tree. </p>
<p>Running time is O(n) where n is the number of nodes in the tree. Explanation: </p><dl class="section see"><dt>See also</dt><dd>TreeCopy() </dd>
<dd>
leftMost() </dd>
<dd>
rightMost() O(n) * 3 = O(n)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The tree to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of the tree </dd></dl>

</div>
</div>
<a id="a977e208a0928ae9384f8e1b4b8c6c1f6" name="a977e208a0928ae9384f8e1b4b8c6c1f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a977e208a0928ae9384f8e1b4b8c6c1f6">&#9670;&#160;</a></span>Tree() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename Comp  = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDM852_1_1Tree.html">DM852::Tree</a>&lt; Key, Value, Comp &gt;::Tree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDM852_1_1Tree.html">Tree</a>&lt; Key, Value, Comp &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor for tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The tree to move</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of the tree </dd></dl>

</div>
</div>
<a id="abd58d8a437aa0a5d9935bf410cc30b2a" name="abd58d8a437aa0a5d9935bf410cc30b2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd58d8a437aa0a5d9935bf410cc30b2a">&#9670;&#160;</a></span>~Tree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename Comp  = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDM852_1_1Tree.html">DM852::Tree</a>&lt; Key, Value, Comp &gt;::~<a class="el" href="classDM852_1_1Tree.html">Tree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor for tree. </p>
<p>Running time is O(n) where n is the number of nodes in the tree. Explanation: </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classDM852_1_1Tree.html#af92c830c94abb527ad8905488bd7e087" title="Deletes all nodes in tree recursively.">clearTraversal()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0e8dc4c1e98cda3a8c2c79a5c9c395e3" name="a0e8dc4c1e98cda3a8c2c79a5c9c395e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e8dc4c1e98cda3a8c2c79a5c9c395e3">&#9670;&#160;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename Comp  = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDM852_1_1Tree.html#a2cdabfd50d18bedb81601092e0f96ff3">value_type</a> &amp; <a class="el" href="classDM852_1_1Tree.html">DM852::Tree</a>&lt; Key, Value, Comp &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the key-value pair of the last node. </p>
<dl class="section return"><dt>Returns</dt><dd>The key-value pair of the last node </dd></dl>

</div>
</div>
<a id="aec1509d3564e7423cdb5d2d2f299f272" name="aec1509d3564e7423cdb5d2d2f299f272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec1509d3564e7423cdb5d2d2f299f272">&#9670;&#160;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename Comp  = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDM852_1_1Tree.html#a2cdabfd50d18bedb81601092e0f96ff3">value_type</a> &amp; <a class="el" href="classDM852_1_1Tree.html">DM852::Tree</a>&lt; Key, Value, Comp &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the key-value pair of the last node. </p>
<dl class="section return"><dt>Returns</dt><dd>The key-value pair of the last node </dd></dl>

</div>
</div>
<a id="af555e96592be4c5fbac4f2049221a9f2" name="af555e96592be4c5fbac4f2049221a9f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af555e96592be4c5fbac4f2049221a9f2">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename Comp  = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDM852_1_1Tree_1_1iterator.html">iterator</a> <a class="el" href="classDM852_1_1Tree.html">DM852::Tree</a>&lt; Key, Value, Comp &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An iterator to the first node in the tree. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first node </dd></dl>

</div>
</div>
<a id="ad98a4e70dfba04329932b519e49a637a" name="ad98a4e70dfba04329932b519e49a637a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad98a4e70dfba04329932b519e49a637a">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename Comp  = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDM852_1_1Tree_1_1const__iterator.html">const_iterator</a> <a class="el" href="classDM852_1_1Tree.html">DM852::Tree</a>&lt; Key, Value, Comp &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A <a class="el" href="classDM852_1_1Tree_1_1const__iterator.html">const_iterator</a> to the first node in the tree. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classDM852_1_1Tree_1_1const__iterator.html">const_iterator</a> to the first node </dd></dl>

</div>
</div>
<a id="aa5d40f18d5b1e41c189415022eb3dc6e" name="aa5d40f18d5b1e41c189415022eb3dc6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d40f18d5b1e41c189415022eb3dc6e">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename Comp  = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDM852_1_1Tree.html">DM852::Tree</a>&lt; Key, Value, Comp &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears tree to empty state. </p>
<p>Running time is O(n) where n is the number of nodes in the tree. Explanation: </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classDM852_1_1Tree.html#af92c830c94abb527ad8905488bd7e087" title="Deletes all nodes in tree recursively.">clearTraversal()</a> </dd></dl>

</div>
</div>
<a id="af92c830c94abb527ad8905488bd7e087" name="af92c830c94abb527ad8905488bd7e087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92c830c94abb527ad8905488bd7e087">&#9670;&#160;</a></span>clearTraversal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename Comp  = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDM852_1_1Tree.html">DM852::Tree</a>&lt; Key, Value, Comp &gt;::clearTraversal </td>
          <td>(</td>
          <td class="paramtype">Node *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes all nodes in tree recursively. </p>
<p>Running time is O(n) where n is the number of nodes in the tree. Explanation: Each node is recursively deleted, thus each node is visited once.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node to start from Iterator class to go through tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a503d781b0509aa27dee80ff16228c073" name="a503d781b0509aa27dee80ff16228c073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a503d781b0509aa27dee80ff16228c073">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename Comp  = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDM852_1_1Tree.html">DM852::Tree</a>&lt; Key, Value, Comp &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether or not the tree is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>True if tree is empty, false otherwise </dd></dl>

</div>
</div>
<a id="afc8fa471527960e1c1989ccb933d397b" name="afc8fa471527960e1c1989ccb933d397b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc8fa471527960e1c1989ccb933d397b">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename Comp  = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDM852_1_1Tree_1_1iterator.html">iterator</a> <a class="el" href="classDM852_1_1Tree.html">DM852::Tree</a>&lt; Key, Value, Comp &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An iterator to the node after the last node in the tree. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the node after the last node </dd></dl>

</div>
</div>
<a id="a5f93254b826a644642c5a9e66e1de320" name="a5f93254b826a644642c5a9e66e1de320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f93254b826a644642c5a9e66e1de320">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename Comp  = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDM852_1_1Tree_1_1const__iterator.html">const_iterator</a> <a class="el" href="classDM852_1_1Tree.html">DM852::Tree</a>&lt; Key, Value, Comp &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A <a class="el" href="classDM852_1_1Tree_1_1const__iterator.html">const_iterator</a> to the node after the last node in the tree. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classDM852_1_1Tree_1_1const__iterator.html">const_iterator</a> to the node after the last node </dd></dl>

</div>
</div>
<a id="a383685f0ef7d362693c4286d10581d0c" name="a383685f0ef7d362693c4286d10581d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a383685f0ef7d362693c4286d10581d0c">&#9670;&#160;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename Comp  = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDM852_1_1Tree_1_1iterator.html">iterator</a> <a class="el" href="classDM852_1_1Tree.html">DM852::Tree</a>&lt; Key, Value, Comp &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds node from key and returns an iterator to it. </p>
<p>This is like findNode, but it returns an iterator instead of a node. If the node is not found, it returns an iterator to <a class="el" href="classDM852_1_1Tree.html#afc8fa471527960e1c1989ccb933d397b" title="An iterator to the node after the last node in the tree.">end()</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classDM852_1_1Tree.html#a4508918bb03bd7ca2a6b7d50ed8ee603" title="Finds node from key.">findNode(const Key &amp;key)</a></dd></dl>
<p>Running time is O(n) where n is the height of the tree. Explanation: In the worst case scenario, we need to go through each node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to find</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to node from key or <a class="el" href="classDM852_1_1Tree.html#afc8fa471527960e1c1989ccb933d397b" title="An iterator to the node after the last node in the tree.">end()</a> if none is found </dd></dl>

</div>
</div>
<a id="a244c259c1dc96e88bf9434c865226dd1" name="a244c259c1dc96e88bf9434c865226dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a244c259c1dc96e88bf9434c865226dd1">&#9670;&#160;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename Comp  = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDM852_1_1Tree_1_1const__iterator.html">const_iterator</a> <a class="el" href="classDM852_1_1Tree.html">DM852::Tree</a>&lt; Key, Value, Comp &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds node from key and returns a <a class="el" href="classDM852_1_1Tree_1_1const__iterator.html">const_iterator</a> to it. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classDM852_1_1Tree.html#a383685f0ef7d362693c4286d10581d0c" title="Finds node from key and returns an iterator to it.">find(const Key &amp;key)</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to find</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const_iterator to node from key or <a class="el" href="classDM852_1_1Tree.html#afc8fa471527960e1c1989ccb933d397b" title="An iterator to the node after the last node in the tree.">end()</a> if none is found </dd></dl>

</div>
</div>
<a id="a4508918bb03bd7ca2a6b7d50ed8ee603" name="a4508918bb03bd7ca2a6b7d50ed8ee603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4508918bb03bd7ca2a6b7d50ed8ee603">&#9670;&#160;</a></span>findNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename Comp  = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Node * <a class="el" href="classDM852_1_1Tree.html">DM852::Tree</a>&lt; Key, Value, Comp &gt;::findNode </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds node from key. </p>
<p>This functions goes through each node to find the one with the specified key. If none is found, it returns nullptr</p>
<p>Running time is O(n) where n is the height of the tree. Explanation: In the worst case scenario, we need to go through each node.</p>
<dl class="section return"><dt>Returns</dt><dd>Node from key or nullptr if none is found </dd></dl>

</div>
</div>
<a id="a759aaf94b760b7a8aaa5fcd345535843" name="a759aaf94b760b7a8aaa5fcd345535843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a759aaf94b760b7a8aaa5fcd345535843">&#9670;&#160;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename Comp  = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDM852_1_1Tree.html#a2cdabfd50d18bedb81601092e0f96ff3">value_type</a> &amp; <a class="el" href="classDM852_1_1Tree.html">DM852::Tree</a>&lt; Key, Value, Comp &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the key-value pair of the first node. </p>
<dl class="section return"><dt>Returns</dt><dd>The key-value pair of the first node </dd></dl>

</div>
</div>
<a id="a7bde2a5d277a75074f4bf7d6000f16d1" name="a7bde2a5d277a75074f4bf7d6000f16d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bde2a5d277a75074f4bf7d6000f16d1">&#9670;&#160;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename Comp  = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDM852_1_1Tree.html#a2cdabfd50d18bedb81601092e0f96ff3">value_type</a> &amp; <a class="el" href="classDM852_1_1Tree.html">DM852::Tree</a>&lt; Key, Value, Comp &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the key-value pair of the first node. </p>
<dl class="section return"><dt>Returns</dt><dd>The key-value pair of the first node </dd></dl>

</div>
</div>
<a id="a8f954a0edfb18670555e188c83605393" name="a8f954a0edfb18670555e188c83605393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f954a0edfb18670555e188c83605393">&#9670;&#160;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename Comp  = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classDM852_1_1Tree_1_1iterator.html">iterator</a>, bool &gt; <a class="el" href="classDM852_1_1Tree.html">DM852::Tree</a>&lt; Key, Value, Comp &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts node into tree. </p>
<p>This function first checks if the key already exists in the tree. If it does, the value is updated. Otherwise, the function checks if the tree is empty. If it is, the root is set to the new node. Otherwise, the function goes through the tree until it finds the correct place to insert the new node.</p>
<p>Running time is O(n) where n is the height of the tree. Explanation: In the worst case scenario, we need to go through each node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to insert </td></tr>
    <tr><td class="paramname">value</td><td>The value to insert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair with an iterator to the inserted node and a bool that is true if the node was inserted, false otherwise </dd></dl>

</div>
</div>
<a id="a75e32bbf2d5e32613d0322898561cdac" name="a75e32bbf2d5e32613d0322898561cdac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e32bbf2d5e32613d0322898561cdac">&#9670;&#160;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename Comp  = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classDM852_1_1Tree_1_1iterator.html">iterator</a>, bool &gt; <a class="el" href="classDM852_1_1Tree.html">DM852::Tree</a>&lt; Key, Value, Comp &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">Key &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts node into tree using move semantics. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classDM852_1_1Tree.html#a8f954a0edfb18670555e188c83605393" title="Inserts node into tree.">insert(const Key &amp;key, const Value &amp;value)</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to insert </td></tr>
    <tr><td class="paramname">value</td><td>The value to insert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair with an iterator to the inserted node and a bool that is true if the node was inserted, false otherwise. </dd></dl>

</div>
</div>
<a id="aa97797b70c35cf0120a59640d39ac84e" name="aa97797b70c35cf0120a59640d39ac84e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa97797b70c35cf0120a59640d39ac84e">&#9670;&#160;</a></span>iteratorTraversal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename Comp  = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDM852_1_1Tree.html">DM852::Tree</a>&lt; Key, Value, Comp &gt;::iteratorTraversal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDM852_1_1Tree.html">Tree</a>&lt; Key, Value, Comp &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for tree. </p>
<p>This operator uses iterators to traverse the trees and compare the values.</p>
<p>Running time is O(n) where n is the number of nodes in the tree. Explanation: Two iterators are used to traverse the trees, and the comparison function is used to compare the values, which are all nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The tree to compare to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the trees are equal, false otherwise </dd></dl>

</div>
</div>
<a id="a48138501534ed99f9841a1a1ce417140" name="a48138501534ed99f9841a1a1ce417140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48138501534ed99f9841a1a1ce417140">&#9670;&#160;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename Comp  = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDM852_1_1Tree.html">DM852::Tree</a>&lt; Key, Value, Comp &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDM852_1_1Tree.html">Tree</a>&lt; Key, Value, Comp &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator for tree. </p>
<p>This operator uses iterators to traverse the trees and compare the values.</p>
<p>Running time is O(n) where n is the number of nodes in the tree. Explanation: </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classDM852_1_1Tree.html#aa97797b70c35cf0120a59640d39ac84e" title="Equality operator for tree.">iteratorTraversal()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The tree to compare to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the trees are not equal, false otherwise </dd></dl>

</div>
</div>
<a id="a4a691e59dbd7ba851da76c29393b1905" name="a4a691e59dbd7ba851da76c29393b1905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a691e59dbd7ba851da76c29393b1905">&#9670;&#160;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename Comp  = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDM852_1_1Tree.html">DM852::Tree</a>&lt; Key, Value, Comp &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDM852_1_1Tree.html">Tree</a>&lt; Key, Value, Comp &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const inequality operator for tree. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classDM852_1_1Tree.html#a48138501534ed99f9841a1a1ce417140" title="Inequality operator for tree.">operator!=(const Tree &amp;other)</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The tree to compare to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51a3358d3236ed0de8a6c7d06b45f44d" name="a51a3358d3236ed0de8a6c7d06b45f44d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a3358d3236ed0de8a6c7d06b45f44d">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename Comp  = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDM852_1_1Tree.html">Tree</a> &amp; <a class="el" href="classDM852_1_1Tree.html">DM852::Tree</a>&lt; Key, Value, Comp &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDM852_1_1Tree.html">Tree</a>&lt; Key, Value, Comp &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator for tree. </p>
<p>Running time is O(n) where n is the number of nodes in the tree. Explanation: </p><dl class="section see"><dt>See also</dt><dd>TreeCopy() </dd>
<dd>
leftMost() </dd>
<dd>
rightMost() O(n) * 3 = O(n)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The tree to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of the tree </dd></dl>

</div>
</div>
<a id="acbf2c770102639da93495434b9e09f86" name="acbf2c770102639da93495434b9e09f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf2c770102639da93495434b9e09f86">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename Comp  = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDM852_1_1Tree.html">Tree</a> &amp; <a class="el" href="classDM852_1_1Tree.html">DM852::Tree</a>&lt; Key, Value, Comp &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDM852_1_1Tree.html">Tree</a>&lt; Key, Value, Comp &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator for tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The tree to move</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of the tree </dd></dl>

</div>
</div>
<a id="a493339e5d0f271518b3db3e257c71cff" name="a493339e5d0f271518b3db3e257c71cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a493339e5d0f271518b3db3e257c71cff">&#9670;&#160;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename Comp  = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDM852_1_1Tree.html">DM852::Tree</a>&lt; Key, Value, Comp &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDM852_1_1Tree.html">Tree</a>&lt; Key, Value, Comp &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator for tree. </p>
<p>This operator uses iterators to traverse the trees and compare the values.</p>
<p>Running time is O(n) where n is the number of nodes in the tree. Explanation: </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classDM852_1_1Tree.html#aa97797b70c35cf0120a59640d39ac84e" title="Equality operator for tree.">iteratorTraversal()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The tree to compare to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the trees are equal, false otherwise </dd></dl>

</div>
</div>
<a id="a8039736d915341aae5604d8be6e170a5" name="a8039736d915341aae5604d8be6e170a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8039736d915341aae5604d8be6e170a5">&#9670;&#160;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename Comp  = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDM852_1_1Tree.html">DM852::Tree</a>&lt; Key, Value, Comp &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDM852_1_1Tree.html">Tree</a>&lt; Key, Value, Comp &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const equality operator for tree. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classDM852_1_1Tree.html#a493339e5d0f271518b3db3e257c71cff" title="Equality operator for tree.">operator==(const Tree &amp;other)</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The tree to compare to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the trees are equal, false otherwise </dd></dl>

</div>
</div>
<a id="a789be3885bde03a00a7254e808e54cbf" name="a789be3885bde03a00a7254e808e54cbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a789be3885bde03a00a7254e808e54cbf">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , typename Comp  = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classDM852_1_1Tree.html">DM852::Tree</a>&lt; Key, Value, Comp &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the tree. </p>
<p>Uses the variable node_count which is incremented when a new node is inserted.</p>
<dl class="section return"><dt>Returns</dt><dd>The size of the tree </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Tree_8hpp_source.html">Tree.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
